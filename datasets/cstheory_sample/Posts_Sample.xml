<?xml version="1.0" encoding="utf-8"?>
<posts>
  <row Id="2" PostTypeId="1" AcceptedAnswerId="20" CreationDate="2010-08-16T19:46:06.793" Score="10" ViewCount="625" Body="&lt;p&gt;I have a dataset which is a number of objects arranged in a 2-D grid.  I know I have a strict ordering, increasing as you go left-to-right within each row, and increasing as top-to-bottom within each column.  For example, &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1 2 3&lt;/li&gt;&#xA;&lt;li&gt;4 6 7&lt;/li&gt;&#xA;&lt;li&gt;5 8 9&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Can I improve on naive sorting to sort the entire dataset linearly (as measured in comparisons)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What about for n-d datasets?  Arbitrary finite datasets with a subset of comparisons known?&lt;/p&gt;&#xA;" OwnerUserId="48" LastEditorUserId="80" LastEditDate="2010-08-16T20:57:38.993" LastActivityDate="2010-08-16T20:57:38.993" Title="What is a good special-case sorting algorithm?" Tags="&lt;ds.algorithms&gt;&lt;total-ordering&gt;&lt;sorting&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="3" PostTypeId="1" AcceptedAnswerId="44" CreationDate="2010-08-16T19:50:13.663" Score="5" ViewCount="320" Body="&lt;p&gt;A particular programming problem I came across recently reduces to finding hamiltonian paths in a rectangular grid that would look something like,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A  0  0  0&#xA;&#xA;0  0  0  0&#xA;&#xA;0  0  C  D&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;What are some effective heuristics that could be applied to find them - and particularly, techniques to trim/discard paths along the way?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit: Just to clarify, the edges are formed when elements are connected horizontally and vertically, but not diagonally. The problem also states that any element that is marked 0 can be used to form a path, but non 0 elements are &quot;obstacles&quot; that need to be avoided. &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A-0-0-0&#xA;      |&#xA;0-0-0-0&#xA;|&#xA;0-0-C D&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;could be one path, for instance. Another may be,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A 0-0-0&#xA;| |   |&#xA;0 0 0-0&#xA;| | |&#xA;0-0 C D&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="35" LastEditorUserId="35" LastEditDate="2010-08-17T00:46:46.777" LastActivityDate="2010-08-17T01:12:55.963" Title="What are some effective heuristics to find the number of Hamiltonian paths in a rectangular grid?" Tags="&lt;ds.algorithms&gt;&lt;hamiltonian-paths&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" />
  <row Id="4" PostTypeId="1" CreationDate="2010-08-16T19:58:52.537" Score="10" ViewCount="428" Body="&lt;p&gt;What is the following variation on set cover known as?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given a set S, a collection C of subsets of S and a positive integer K, do there exist K sets in C such that every pair of elements of S lies in one of the selected subsets.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note: It is not hard to see that this problem is NP-Complete:  Given a normal set cover problem (S, C, K), make three copies of S, say S', S'', and S''',  then create your subsets as S''', |S| subsets of the form {a'} U {x in S'' | x != a} U {a'''}, |S| subsets of the form {a''} U {x in S' | x != a} U {a'''}, {a', a'' | a in C_i}.  Then we can solve the set cover problem with K subsets iff we can solve the pair cover problem with K + 1 + 2 |S| subsets.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This generalizes to triples, etc.  I would like to be able to not waste half a page proving this, and it is probably not obvious enough to dismiss as trivial.  It is certainly sufficiently useful that someone has proved it, but I have no idea who or where.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, is there a good place to look for NP-Completeness results that are not in Garey and Johnson?&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="80" LastEditDate="2010-08-16T20:25:11.147" LastActivityDate="2010-08-16T20:57:29.213" Title="What is the following variation on Set Cover known as?" Tags="&lt;np-hardness&gt;&lt;set-cover&gt;&lt;cc.complexity-theory&gt;" AnswerCount="2" FavoriteCount="2" />
  <row Id="5" PostTypeId="1" AcceptedAnswerId="22" CreationDate="2010-08-16T20:05:19.027" Score="5" ViewCount="223" Body="&lt;p&gt;Can the divide and conquer nature of the FFT be generalized to other transforms (z Transform, chirp, etc) automatically?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there an algorithm that takes in a description of transform (I don't know what information would be needed) and can produce a fast FFT like function?&lt;/p&gt;&#xA;" OwnerUserId="64" LastActivityDate="2010-08-16T20:47:42.030" Title="Generalizing the FFT" Tags="&lt;ds.algorithms&gt;" AnswerCount="1" FavoriteCount="0" />
  <row Id="6" PostTypeId="1" AcceptedAnswerId="9" CreationDate="2010-08-16T20:05:51.693" Score="5" ViewCount="143" Body="&lt;p&gt;Is anyone aware of any process algebraic (or related) formalisms that capture fine-grained location information?  I'm familiar with ambients and bigraphs, which obviously have a location model, but what about attempts to model more concrete location information, such that the location of some agent is expressed within some (real or virtual) coordinate space?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems to me that it would be possible to take some existing formalism and enrich it with constructs to model location at some appropriate level of abstraction, but I would hate to reinvent the wheel needlessly if this is reminiscent of previous efforts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As background, the application domain is essentially biological modeling where the traditional notions of location used in this domain to govern where interactions can occur are not fine-grained enough to capture the properties of interest.&lt;/p&gt;&#xA;" OwnerUserId="47" LastActivityDate="2010-08-16T20:16:17.470" Title="Process modeling with fine-grained notions of location" Tags="&lt;concurrency&gt;&lt;process-algebra&gt;&lt;formal-modeling&gt;" AnswerCount="1" FavoriteCount="1" />
  <row Id="7" PostTypeId="1" AcceptedAnswerId="247" CreationDate="2010-08-16T20:10:16.987" Score="14" ViewCount="337" Body="&lt;p&gt;In general, the query-tape for an oracle counts towards the space-complexity of a TM. However, it seems plausible to allow a write-only oracle-tape (such as is used in L-space reductions).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is such a construction useful? Does it yield any particularly absurd results?&lt;/p&gt;&#xA;" OwnerUserId="63" LastEditorUserId="80" LastEditDate="2010-08-16T20:40:49.097" LastActivityDate="2010-08-24T18:44:15.433" Title="space-bounded TMs and oracles" Tags="&lt;cc.complexity-theory&gt;&lt;space-bounded&gt;&lt;oracles&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="2" />
  <row Id="8" PostTypeId="2" ParentId="2" CreationDate="2010-08-16T20:11:04.240" Score="2" Body="&lt;p&gt;If I understand the problem correctly (and I may not, feel free to tell me if I don't) you want to transform a 2D grid into a sorted 1D array, whereas each row and column is already sorted in the 2D grid?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first element in the list in this case has to be the top-left corner ((0,0), by definition of the problem). After this it has to either be the (1,0) or (0,1) element, as all others will be larger than these by definition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can generalise by saying that the next smallest element in the grid is always directly below an element already used (or the edge of grid), and also to the right of an element already used (or the edge of grid), since both are defined to be smaller than it.&#xA;So at each iteration you must only consider the smallest value that fulfills this requirement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can keep the possible candidates in sorted order as you find them (no more than two will ever be made available in one iteration), and at each iteration check the new values made available (if any).&#xA;If they're lower than the lowest of the previous candidates add them to the list straight away and repeat, otherwise add the lowest previous candidate and compare to the next lowest etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately I don't claim to be able to provide an exact complexity of this, nor do I claim it's the most efficient possible, it certainly seems better than a naive approach, and I hope I explained it well enough for you to understand.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT: For n-d grids like this I believe the same basic principle applies, but each iteration makes up to n new candidates available, and these candidates must be the smallest unused elements in each of n dimensions at this point.&lt;/p&gt;&#xA;" OwnerUserId="14" LastEditorUserId="14" LastEditDate="2010-08-16T20:42:03.493" LastActivityDate="2010-08-16T20:42:03.493" CommentCount="1" />
  <row Id="9" PostTypeId="2" ParentId="6" CreationDate="2010-08-16T20:16:17.470" Score="6" Body="&lt;p&gt;&lt;a href=&quot;http://www.doc.ic.ac.uk/~pg/papers/geometric.pdf&quot; rel=&quot;nofollow&quot;&gt;Processes in Space&lt;/a&gt; by Luca Cardelli and Philippa Gardner is one paper in this direction. It specified a process algebra for describing the evolution of 3D structures. &lt;/p&gt;&#xA;" OwnerUserId="77" LastActivityDate="2010-08-16T20:16:17.470" CommentCount="1" />
  <row Id="10" PostTypeId="1" AcceptedAnswerId="18" CreationDate="2010-08-16T20:21:20.173" Score="5" ViewCount="1549" Body="&lt;p&gt;There was recently a claimed &lt;a href=&quot;http://science.slashdot.org/story/10/08/08/226227/Claimed-Proof-That-P--NP&quot; rel=&quot;nofollow&quot;&gt;proof that $P \ne NP$&lt;/a&gt;. Not long after its publication there were raised &lt;a href=&quot;http://slashdot.org/story/10/08/11/0239209/Possible-Issues-With-the-P--NP-Proof&quot; rel=&quot;nofollow&quot;&gt;some issues&lt;/a&gt; with this proof.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So ... is the proof correct or not ? (Please only answer this if you have evidence ... this question might take some time until it's answered)&lt;/p&gt;&#xA;" OwnerUserId="81" LastEditorUserId="2241" LastEditDate="2012-01-14T13:45:16.260" LastActivityDate="2012-01-14T13:45:16.260" Title="Is Deolalikar's 2010 proof that $P \ne NP$ correct?" Tags="&lt;np-hardness&gt;&lt;cc.complexity-theory&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="1" />
  <row Id="11" PostTypeId="1" AcceptedAnswerId="256" CreationDate="2010-08-16T20:21:43.683" Score="37" ViewCount="1792" Body="&lt;p&gt;Functional programming has a theoretical basis in &lt;a href=&quot;http://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;lambda calculus&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Combinatory_logic&quot;&gt;combinatory logic&lt;/a&gt;.  As someone involved with statistical computing, I find these concepts to be very useful for modeling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there an equivalent mathematical basis of &lt;a href=&quot;http://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperative programming&lt;/a&gt;, or did it simply grow out of practical hardware application in machine language and the subsequent development of &lt;a href=&quot;http://en.wikipedia.org/wiki/FORTRAN&quot;&gt;FORTRAN&lt;/a&gt;?&lt;/p&gt;&#xA;" OwnerUserId="7" LastEditorUserId="74" LastEditDate="2010-08-21T20:37:23.677" LastActivityDate="2012-02-28T10:50:49.727" Title="What is the theoretical basis of imperative programming?" Tags="&lt;imperative-programming&gt;&lt;pl.programming-languages&gt;" AnswerCount="11" FavoriteCount="11" />
  <row Id="12" PostTypeId="1" AcceptedAnswerId="13" CreationDate="2010-08-16T20:27:39.673" Score="25" ViewCount="668" Body="&lt;p&gt;I took a class once on Computability and Logic. The material included a correlation between complexity / computability classes (R, RE, co-RE, P, NP, Logspace, ...) and Logics (Predicate calculus, first order logic, ...).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The correlation included several results in one fields, that were obtained using techniques from the other field. It was conjectured that P != NP could be attacked as a problem in Logic (by projecting the problem from the domain of complexity classes to logics).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there a good summary of these techniques and results?&lt;/p&gt;&#xA;" OwnerUserId="81" LastEditorUserId="80" LastEditDate="2010-08-16T20:32:20.710" LastActivityDate="2010-09-07T08:10:18.160" Title="Correspondence between complexity classes and logic" Tags="&lt;cc.complexity-theory&gt;&lt;lo.logic&gt;&lt;computability&gt;" AnswerCount="4" FavoriteCount="8" />
  <row Id="13" PostTypeId="2" ParentId="12" CreationDate="2010-08-16T20:31:32.583" Score="18" Body="&lt;p&gt;It's possible that you're asking about results in finite model theory (such as the characterization of P and NP in terms of various fragments of logic). The recent attempted proof of P != NP initially made heavy use of such concepts, and some good references (taken from the &lt;a href=&quot;http://michaelnielsen.org/polymath1/index.php?title=Deolalikar_P_vs_NP_paper&quot;&gt;wiki&lt;/a&gt;) are &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.logic.rwth-aachen.de/pub/graedel/FMTbook-Chapter3.pdf&quot;&gt;Erich Gradel's review of FMT and descriptive complexity&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=38D2317557C5EF25F3ED6D0D3CBE6E69?doi=10.1.1.28.6917&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Ron Fagin's article on descriptive complexity&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="80" LastActivityDate="2010-08-16T20:31:32.583" CommentCount="1" />
  <row Id="14" PostTypeId="1" CreationDate="2010-08-16T20:32:00.193" Score="19" ViewCount="1086" Body="&lt;p&gt;Other than going fully academic and getting a doctorate/post-doc, or going for a more or less 'standard' job in software development, what are some other career options in the full or semi theoretical C.S field?&lt;/p&gt;&#xA;" OwnerUserId="81" LastEditorUserId="1037" LastEditDate="2012-02-08T17:42:24.397" LastActivityDate="2012-02-08T17:42:24.397" Title="What are some career options for someone with a computer scientist master degree?" Tags="&lt;soft-question&gt;&lt;advice-request&gt;&lt;career&gt;" AnswerCount="5" CommentCount="5" FavoriteCount="7" CommunityOwnedDate="2010-08-17T06:10:22.320" />
  <row Id="15" PostTypeId="1" CreationDate="2010-08-16T20:32:53.500" Score="15" ViewCount="371" Body="&lt;p&gt;[This question has been asked on MathOverflow with no luck a month ago.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me first clarify my definitions.  For a word $w \in \Sigma^*$, with $\Sigma =\{a_1,&#xD;&#xA;\ldots, a_n\}$, I define two structures:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\mathbb{N}(w) = \langle \mathbb{N}, &amp;lt;, Q_{a_1}, \ldots, Q_{a_n} \rangle$,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and the more usual &lt;i&gt;word model&lt;/i&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\mathbb{N}^r(w) = \langle \{0, \ldots, |w|-1\}, &amp;lt;, Q_{a_1}, \ldots, Q_{a_n} \rangle$,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $Q_{a_i} = \{p \mid w_p = a_i\}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then WS1S is the set of second order formulas with models of the form&#xA;$\mathbb{N}(w)$, with order, and for which second order quantification is&#xA;limited to finite subsets of the domain.  MSO is the set of second order&#xA;formulas with models of the form $\mathbb{N}^r(w)$, with order.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The usual proof that REG = WS1S proves at the same time that MSO = WS1S.  My&#xA;question is then, for which first or second order relations can we keep this&#xA;to be true?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance, if we add a unary predicate $E(X)$ which says that a&#xA;(monadic) second order variable contains an even number of objects, we add no&#xA;power, as $E(X)$ is expressible as &quot;there exists $X_1$ and&#xA;$X_2$ that partition $X$, in such a way that if an element is in&#xA;$X_i$ the next one in $X$ is in $X_j$, $i \neq j$, and&#xA;the first element of $X$ is in $X_1$ and the last is in&#xA;$X_2$.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, if we add a predicate $|X| &amp;lt; |Y|$, then WS1S becomes undecidable&#xA;(see Klaedtke &amp;amp; Ruess, 10.1.1.7.3029), while MSO stays trivially decidable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thank you.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;b&gt;Edit:&lt;/b&gt; As a side question, ... is this question of interest?  I mean, I'm no expert in the field, so I'm not sure this question is relevant.&lt;/p&gt;&#xA;" OwnerUserId="88" LastEditorUserId="77" LastEditDate="2011-02-24T08:11:47.110" LastActivityDate="2011-02-24T08:11:47.110" Title="To what extent MSO = WS1S, when adding relations?" Tags="&lt;lo.logic&gt;&lt;automata-theory&gt;&lt;descriptive-complexity&gt;" AnswerCount="0" CommentCount="6" />
  <row Id="16" PostTypeId="2" ParentId="10" CreationDate="2010-08-16T20:32:57.867" Score="19" Body="&lt;p&gt;See the &lt;a href=&quot;http://michaelnielsen.org/polymath1/index.php?title=Deolalikar_P_vs_NP_paper&quot; rel=&quot;nofollow&quot;&gt;wiki&lt;/a&gt;. &lt;/p&gt;&#xA;" OwnerUserId="80" LastActivityDate="2010-08-16T20:32:57.867" />
  <row Id="17" PostTypeId="1" AcceptedAnswerId="23" CreationDate="2010-08-16T20:33:42.140" Score="13" ViewCount="494" Body="&lt;p&gt;it is often said that when using the MD5 algorithm to sign some arbitrary information, the shared secret has to be at the end. Why?&lt;/p&gt;&#xA;" OwnerUserId="87" LastEditorUserId="74" LastEditDate="2010-08-23T23:54:23.390" LastActivityDate="2010-08-23T23:54:23.390" Title="Why is it important that the secret is at the end when signing with MD5?" Tags="&lt;hash-function&gt;&lt;cr.crypto-security&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="4" />
  <row Id="18" PostTypeId="2" ParentId="10" CreationDate="2010-08-16T20:36:48.810" Score="16" Body="&lt;p&gt;In one word: No.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems that there are some fatal flaws in Deolalikar's proposed proof. The real question now is if the &quot;proof&quot; has any useful ideas that can be built upon. In any case, it seems that the proof in its current form simply isn't correct, and can't be corrected either. On the other hand, Deolalikar has not given up on the proof, so I guess it's not the end of it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can find an update here: &lt;a href=&quot;http://rjlipton.wordpress.com/2010/08/15/the-p%E2%89%A0np-proof-is-one-week-old/&quot; rel=&quot;nofollow&quot;&gt;http://rjlipton.wordpress.com/2010/08/15/the-p%E2%89%A0np-proof-is-one-week-old/&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="90" LastActivityDate="2010-08-16T20:36:48.810" />
  <row Id="19" PostTypeId="2" ParentId="11" CreationDate="2010-08-16T20:39:06.183" Score="15" Body="&lt;p&gt;In short, I would say that imperative programming evolved from machine language and programming practice. On the other hand, &lt;a href=&quot;http://en.wikipedia.org/wiki/Monad_%28functional_programming%29&quot;&gt;monads&lt;/a&gt; provide an appropriate semantic framework for describing the semantics of imperative programming language features. The paper   &lt;a href=&quot;http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf&quot;&gt;&lt;em&gt;Notions of computation and monads&lt;/em&gt;&lt;/a&gt; by Moggi established the formal foundations. Phil Wadler popularised the idea and contributed significantly to it being the key way of incorporating imperative features into the programming language Haskell. Recent work by Plotkin and Power &lt;a href=&quot;http://hdl.handle.net/1842/196&quot;&gt;&lt;em&gt;Notions of Computation Determine Monads&lt;/em&gt;&lt;/a&gt; goes the other way stating that some, but not all, notions of (imperative) computation actually give a monad, meaning that in a very essential way monads correspond to imperative (and other) notions of computation.&lt;/p&gt;&#xA;" OwnerUserId="77" LastActivityDate="2010-08-16T20:39:06.183" CommentCount="2" />
