<?xml version="1.0" encoding="utf-8"?>
<posthistory>
  <row Id="4" PostHistoryTypeId="2" PostId="2" RevisionGUID="0e252b9b-6a8f-45d1-9ed8-48353962a914" CreationDate="2010-08-16T19:46:06.793" UserId="48" Text="I have a dataset which is a number of objects arranged in a 2-D grid.  I know I have a strict ordering, increasing as you go left-to-right along each row, and top-to-bottom along each column.  Can I improve on naive sorting (measured in comparisons, naturally)?&#xD;&#xA;&#xD;&#xA;What about for n-d datasets?  Arbitrary finite datasets with a subset of comparisons known?" />
  <row Id="5" PostHistoryTypeId="1" PostId="2" RevisionGUID="0e252b9b-6a8f-45d1-9ed8-48353962a914" CreationDate="2010-08-16T19:46:06.793" UserId="48" Text="What is a good special-case sorting algorithm?" />
  <row Id="6" PostHistoryTypeId="3" PostId="2" RevisionGUID="0e252b9b-6a8f-45d1-9ed8-48353962a914" CreationDate="2010-08-16T19:46:06.793" UserId="48" Text="&lt;sorting&gt;&lt;ds.algorithms&gt;&lt;complexity&gt;&lt;total&gt;&lt;ordering&gt;" />
  <row Id="7" PostHistoryTypeId="2" PostId="3" RevisionGUID="b009d45c-51b7-4a72-ad99-df1781490406" CreationDate="2010-08-16T19:50:13.663" UserId="35" Text="A particular programming problem I came across recently reduces to finding hamiltonian paths in a rectangular grid that would look something like,&#xD;&#xA;&#xD;&#xA;    A  0  Y  X&#xD;&#xA;    &#xD;&#xA;    0  B  0  0&#xD;&#xA;    &#xD;&#xA;    0  0  C  D&#xD;&#xA;&#xD;&#xA;What are some effective heuristics that could be applied to find them - and particularly, techniques to trim/discard paths along the way?" />
  <row Id="8" PostHistoryTypeId="1" PostId="3" RevisionGUID="b009d45c-51b7-4a72-ad99-df1781490406" CreationDate="2010-08-16T19:50:13.663" UserId="35" Text="What are some effective heuristics to find the number of Hamiltonian paths in a rectangular grid?" />
  <row Id="9" PostHistoryTypeId="3" PostId="3" RevisionGUID="b009d45c-51b7-4a72-ad99-df1781490406" CreationDate="2010-08-16T19:50:13.663" UserId="35" Text="&lt;ds.algorithms&gt;&lt;hamiltonian-paths&gt;" />
  <row Id="11" PostHistoryTypeId="6" PostId="2" RevisionGUID="46f55f9a-d4c8-44e7-a9e1-5504fbbd369c" CreationDate="2010-08-16T19:54:03.343" UserId="48" Comment="edited tags" Text="&lt;ds.algorithms&gt;&lt;complexity&gt;&lt;sorting&gt;&lt;total-ordering&gt;" />
  <row Id="12" PostHistoryTypeId="2" PostId="4" RevisionGUID="70aa29ae-bd1b-46c1-8d21-6d1fdb7c8d4b" CreationDate="2010-08-16T19:58:52.537" UserId="54" Text="What is the following variation on set cover known as?&#xD;&#xA;&#xD;&#xA;Given a set S, a collection C of subsets of S and a positive integer K, do there exist K sets in C such that every pair of elements of S lies in one of the selected subsets.&#xD;&#xA;&#xD;&#xA;Note: It is not hard to see that this problem is NP-Complete:  Given a normal set cover problem (S, C, K), make three copies of S, say S', S'', and S''',  then create your subsets as S''', |S| subsets of the form {a'} U {x in S'' | x != a} U {a'''}, |S| subsets of the form {a''} U {x in S' | x != a} U {a'''}, {a', a'' | a in C_i}.  Then we can solve the set cover problem with K subsets iff we can solve the pair cover problem with K + 1 + 2 |S| subsets.&#xD;&#xA;&#xD;&#xA;This generalizes to triples, etc.  I would like to be able to not waste half a page proving this, and it is probably not obvious enough to dismiss as trivial.  It is certainly sufficiently useful that someone has proved it, but I have no idea who or where.&#xD;&#xA;&#xD;&#xA;Also, is there a good place to look for NP-Completeness results that are not in Garey and Johnson?" />
  <row Id="13" PostHistoryTypeId="1" PostId="4" RevisionGUID="70aa29ae-bd1b-46c1-8d21-6d1fdb7c8d4b" CreationDate="2010-08-16T19:58:52.537" UserId="54" Text="What is the following variation on Set Cover known as?" />
  <row Id="14" PostHistoryTypeId="3" PostId="4" RevisionGUID="70aa29ae-bd1b-46c1-8d21-6d1fdb7c8d4b" CreationDate="2010-08-16T19:58:52.537" UserId="54" Text="&lt;complexity&gt;&lt;np-hardness&gt;" />
  <row Id="15" PostHistoryTypeId="5" PostId="2" RevisionGUID="ffcebab1-a531-47f4-8d08-99f118a3be8b" CreationDate="2010-08-16T20:05:05.627" UserId="48" Comment="added 76 characters in body; edited tags; added 21 characters in body" Text="I have a dataset which is a number of objects arranged in a 2-D grid.  I know I have a strict ordering, increasing as you go left-to-right within each row, and increasing as top-to-bottom within each column.  For example, &#xD;&#xA;  &#xD;&#xA;&#xD;&#xA; - 1 2 3&#xD;&#xA; - 4 6 7&#xD;&#xA; - 5 8 9&#xD;&#xA;&#xD;&#xA;Can I improve on naive sorting to sort the entire dataset linearly (as measured in comparisons)?&#xD;&#xA;&#xD;&#xA;What about for n-d datasets?  Arbitrary finite datasets with a subset of comparisons known?" />
  <row Id="16" PostHistoryTypeId="6" PostId="2" RevisionGUID="ffcebab1-a531-47f4-8d08-99f118a3be8b" CreationDate="2010-08-16T20:05:05.627" UserId="48" Comment="added 76 characters in body; edited tags; added 21 characters in body" Text="&lt;ds.algorithms&gt;&lt;complexity&gt;&lt;total-ordering&gt;&lt;sorting&gt;" />
  <row Id="17" PostHistoryTypeId="2" PostId="5" RevisionGUID="e3e246c7-d120-4ac0-8166-b95a9df49d01" CreationDate="2010-08-16T20:05:19.027" UserId="64" Text="Can the divide and conquer nature of the FFT be generalized to other transforms (z Transform, chirp, etc) automatically?&#xD;&#xA;&#xD;&#xA;Is there an algorithm that takes in a description of transform (I don't know what information would be needed) and can produce a fast FFT like function?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="18" PostHistoryTypeId="1" PostId="5" RevisionGUID="e3e246c7-d120-4ac0-8166-b95a9df49d01" CreationDate="2010-08-16T20:05:19.027" UserId="64" Text="Generalizing the FFT" />
  <row Id="19" PostHistoryTypeId="3" PostId="5" RevisionGUID="e3e246c7-d120-4ac0-8166-b95a9df49d01" CreationDate="2010-08-16T20:05:19.027" UserId="64" Text="&lt;ds.algorithms&gt;" />
  <row Id="20" PostHistoryTypeId="2" PostId="6" RevisionGUID="cfb23913-d589-4392-b832-7f80ec820fb3" CreationDate="2010-08-16T20:05:51.693" UserId="47" Text="Is anyone aware of any process algebraic (or related) formalisms that capture fine-grained location information?  I'm familiar with ambients and bigraphs, which obviously have a location model, but what about attempts to model more concrete location information, such that the location of some agent is expressed within some (real or virtual) coordinate space?&#xD;&#xA;&#xD;&#xA;It seems to me that it would be possible to take some existing formalism and enrich it with constructs to model location at some appropriate level of abstraction, but I would hate to reinvent the wheel needlessly if this is reminiscent of previous efforts.&#xD;&#xA;&#xD;&#xA;As background, the application domain is essentially biological modeling where the traditional notions of location used in this domain to govern where interactions can occur are not fine-grained enough to capture the properties of interest." />
  <row Id="21" PostHistoryTypeId="1" PostId="6" RevisionGUID="cfb23913-d589-4392-b832-7f80ec820fb3" CreationDate="2010-08-16T20:05:51.693" UserId="47" Text="Process modeling with fine-grained notions of location" />
  <row Id="22" PostHistoryTypeId="3" PostId="6" RevisionGUID="cfb23913-d589-4392-b832-7f80ec820fb3" CreationDate="2010-08-16T20:05:51.693" UserId="47" Text="&lt;concurrency&gt;&lt;process-algebra&gt;&lt;formal-modeling&gt;" />
 </posthistory>
